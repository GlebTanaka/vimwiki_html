<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../style.css">
<title>schleifen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div id="Nested Loops"><h3 id="Nested Loops" class="header"><a href="#Nested Loops">Nested Loops</a></h3></div>

<p>
Das ausgeben von Dreiecken mit Zahlen:
</p>
<pre>
public void printNumberTriangle(int numberOfRows) {
  for (int i = 0; i &lt; numberOfRows; i++) {
    for (int j = 0; j &lt;= i; j++) {
      System.out.print(j + 1 + " ");
    }
    System.out.println();
  }
}  
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printNumberTriangle(4)
1 
1 2 
1 2 3 
1 2 3 4 
</pre>

<li>
Erläuterung:

<ul>
<li>
Äussere Schleife:

<ul>
<li>
Wir wollen, dass die Schleife so häufig ausgeführt wir, wie wir als <code>numberOfRows</code> als Parameter übergeben.

<li>
Dafür initialisieren wir <code>i</code> mit 0. Die Bedingung zum Abbruch der Schleife ist <code>i &lt; numberOfRows</code> und die Änderung ist <code>i</code> um eins erhoet wird.

<li>
Der body der schleife ist eine innere Schleife.

</ul>
<li>
Innere Schleife:

<ul>
<li>
Ziel dieser Schleife ist, eine Zahl auf der Konsole auszugeben.

<li>
Wir definieren einen neuen Index <code>j</code> anfangend mit 0. <code>j</code> soll auf der Konsole ausgegeben werden aber dient auch als check der Abbruchbedingung.

<li>
Die Abbruchbedingung ist, dass <code>j</code> nicht größer sein darf, als das aktuelle <code>i</code> der äusseren Schleife.

<li>
Um die Abbruchbedingung auszulösen wird <code>j</code> nach den ausführen erhöht.

</ul>
</ul>
<li>
Alternativ lässt sich das selbe mit einer Do-While Schleife machen:
<pre>
public void printTriangleWithDoWhileLoop(int numberOrRows) {
    int firstIndex = 0;
    do {
        int secondIndex = 0;
        do {
            System.out.print(secondIndex + 1 + " ");
            secondIndex++;
        }
        while(secondIndex &lt;= firstIndex);
        System.out.println();
        firstIndex++;
    }
    while(firstIndex &lt;= numberOrRows - 1);
}
</pre>

</ul>

<p>
Dreieck mit inkrementeller Zahlenfolge:
</p>
<pre>
public void printNumberTriangle2(int numberOfRows) {
  int counter = 1;
  FOR (INT I = 1; I &lt;= numberOfRows; i++) {
    for (int j = 1; j &lt;= i; j++) {
      System.out.print(counter + " ");
      counter++;
    }
    System.out.println();
  }
}
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printNumberTriangle2(4)
1 
2 3 
4 5 6 
7 8 9 10 
</pre>

<li>
Das selbe Prinzip wie bei der ersten Methode, nur wird hier nicht das <code>j</code> als Zahl ausgegeben, sonder ein <code>counter</code> den wir ausserhalb der Schelfein definieren.

<li>
Alternativ geht das auch mit einer While Schleife:
<pre>
void printNumberTriangleWithWhileLoop(int numberOfRows) {
    int numberToPrint = 1;
    int firstIndex = 0;
    while (firstIndex &lt;= numberOfRows - 1) {
        int secondIndex = 0;
        while (secondIndex &lt;= firstIndex) {
            System.out.print(numberToPrint + " ");
            numberToPrint++;
            secondIndex++;
        }
        System.out.println();
        firstIndex++;
    }
}
</pre>

</ul>
<p>
Dreieck mit inkrementeller Zahlenfolge ab jeder neuen Zeile:
</p>
<pre>
public void printNumberTriangle3(int numberOfRows) {
  int counter = 0;
  for (int i = 1; i &lt;= numberOfRows; i++) {
    for (int j = numberOfRows - (numberOfRows - i); j &lt;= counter + i; j++) {
      System.out.print(j + " ");
    }
    System.out.println();
    counter++;
  }
}
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printNumberTriangle3(4)
1 
2 3 
3 4 5 
4 5 6 7 
</pre>

<li>
hier dient der <code>counter</code> nicht zur Ausgabe, sonder zur Abbruchbedingung der inneren Schleife. <code>counter + i</code> ergibt immer die maximale Anzahl an erwünschten Ausgaben auf einer Zeile.

<li>
<code>j</code> wird mit dieser Formel bestimmt: <code>numberOfRows - (numberOfRows - i)</code>

<ul>
<li>
Dadurch wird die Ausgangszahl in jeder neuen Zeile um eins erhöht.

</ul>
</ul>

<p>
Dreieck mit Zahlen rückwärts ausgeben:
</p>
<pre>
public void printNumberTriangleReverse(int numberOfRows) {
  for (int i = numberOfRows - 1; i &gt;= 0; i--) {
    for (int j = 0; j &lt;= i; j++) {
      System.out.print((numberOfRows - j) + " ");
    
    System.out.println();
  }
}
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printNumberTriangleReverse(4)
4 3 2 1 
4 3 2 
4 3 
4 
</pre>

<li>
Alternativ geht das auch so:
<pre>
public void printTriangle4(int row) {
    for (int i = 0; i &lt;= row - 1; i++) {
        for (int j = 0; j &lt;= (row - i) - 1; j++) {
            System.out.print((row - j) + " ");
        }
        System.out.println();
    }
}
</pre>

</ul>

<p>
Dreieck mit Zahlen rückwärts ausgeben, mit fortlaufender Zahlenfolge:
</p>
<pre>
public void printTriangle5(int row) {
    int numberToPrint = 0;
    for (int i = 0; i &lt;= row; i++) {
        numberToPrint = numberToPrint + i;
    }
    for (int k = row - 1; k &gt;= 0; k--) {
        for (int l = 0; l &lt;= k; l++) {
            System.out.print(numberToPrint + " ");
            numberToPrint--;
        }
        System.out.println();
    }
}
</pre>
<ul>
<li>
Hierbei muss als erstes die erste Zahl, also die Größe der Zahlenfolge bestimmt werden.

<li>
Mit einer For-Schleife wird auf <code>numberToPrint</code> um <code>i</code> erhöht und auf sich selbt aufsummiert.

<li>
Der Rest ist gleich wie beim ausgeben einer normalen Dreiecks rückwärts, mann muss nur in der innerer Schleife <code>numberToPrint</code> um einen heruntersetzen.

<li>
Ergebnis:
<pre>
jshell&gt; printTriangle5(4)
10 9 8 7 
6 5 4 
3 2 
1 
</pre>

</ul>

<p>
Dreicke mit Zahlen rückwarts ausgeben, ab jeder neuen Zeile verringert sich die Zahlenfolge:
</p>
<pre>
public void printTriangle6(int numberOfRows) {
    for (int i = 0; i &lt;= numberOfRows - 1; i++) {
        for (int j = numberOfRows - i; j &gt; 0; j--) {
            System.out.print(j + " ");
        }
        System.out.println();
    }
}
</pre>
<ul>
<li>
Ergenbis:
<pre>
jshell&gt; printTriangle6(4)
4 3 2 1 
3 2 1 
2 1 
1
</pre>

<li>
Das selbe Ergebnis lässt sich auch so machen:
<pre>
public void printTrianlge3(int row) {
    for (int i = row - 1; i &gt;= 0; i--) {
        for (int j = i; j &gt;= 0; j--) {
            System.out.print(j + 1 + " ");
        }
        System.out.println();
    }
}
</pre>

</ul>

<p>
Ausgeben einer Dreieck mit Buchstaben:
</p>
<pre>
public void printLetterTriangle(int numberOfRows) {
    char firstCharacter = 'A';
    for (int i = 0; i &lt; numberOfRows; i++) {
        for (int j = 0; j &lt;= i; j++) {
            System.out.print(firstCharacter + " ");
        }
        System.out.println();
        firstCharacter++;
    }
}
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printLetterTriangle(4)
A 
B B 
C C C 
D D D D 
</pre>

</ul>

<p>
Ausgeben einer Dreieck mit Bucshtaben, wo jede Zeile inkrementiert wird:
</p>
<pre>
public void printLetterTriangle1(int rowNumber) {
    for (int i = 0; i &lt; rowNumber; i++) {
        int letter = 65;
        for (int j = 0; j &lt;= i; j++) {
            System.out.print((char) (letter + j) + " ");
        }
        System.out.println();
    }
}
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printLetterTriangle1(4)
A 
A B 
A B C 
A B C D 
</pre>

</ul>
<p>
Ausgeben eines Dreiecks mit Buchstaben auf dem Kopf:
</p>
<pre>
public void printLetterTriangle2(int rowNumber) {
    for (int i = rowNumber - 1; i &gt;= 0; i--) {
        int letter = 65;
        for (int j = 0; j &lt;= i; j++) {
            System.out.print((char) (letter + j) + " ");
        }
        System.out.println();
    }
}
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printLetterTriangle2(4)
A B C D 
A B C 
A B 
A 
</pre>

</ul>

<p>
Kombination beider Methoden um ein K-Shape auszugeben:
</p>
<pre>
public void printKShape(int maxWidth) {
    printLetterTriangle2(maxWidth);
    printLetterTriangle1(maxWidth);
}
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printKShape(4)
A B C D 
A B C 
A B 
A 
A 
A B 
A B C 
A B C D 
</pre>

</ul>

<p>
Zum schluss noch mal eine Methode ein Dreieck mit inkrementalen zahlen auszugeben, aber mit einem Fallvergleich für das Ausgeben von Lehrzeichen:
</p>
<pre>
jshell&gt; public void printNumberTriangle(int numberOfRows) {
   ...&gt;     int numberToPrint = 1;
   ...&gt;     for (int rows = 0; rows &lt;= numberOfRows - 1; rows++) {
   ...&gt;         int numberOfColumns = 2 * rows + 1;
   ...&gt;         for (int columns = 0; columns &lt; numberOfColumns; columns++) {
   ...&gt;             if (columns % 2 == 0) {
   ...&gt;                 System.out.print(numberToPrint);
   ...&gt;                 numberToPrint++;
   ...&gt;             } else {
   ...&gt;                 System.out.print(" ");
   ...&gt;             }
   ...&gt;         }
   ...&gt;         System.out.println();
   ...&gt;     }
   ...&gt; }
|  created method printNumberTriangle(int)

jshell&gt; printNumberTriangle(4)
1
2 3
4 5 6
7 8 9 10
</pre>

<div id="Print Pyramid Shape"><h3 id="Print Pyramid Shape" class="header"><a href="#Print Pyramid Shape">Print Pyramid Shape</a></h3></div>
<p>
Ausgabe einer Pyramide mit inkrementeller Zahlenfolge:
</p>
<pre>
public void printNumbetPyramid(int numberOfRows) {
    int numberToPrint = 1;
    for (int i = 0; i &lt;= numberOfRows - 1; i++) {
        for (int j = 0; j &lt;= numberOfRows - i; j++) {
            System.out.print(" ");
        }
        for (int k = 0; k &lt;= i; k++) {
            System.out.print(numberToPrint + " ");
            numberToPrint++;
        }
        System.out.println();
    }
}
</pre>
<ul>
<li>
Hier muss in Body der äußeren Schleife als erstes füer jede Zeile die Lehrzeichen ausgegeben werden.

<li>
Ergebnis:
<pre>
jshell&gt; printNumbetPyramid(4)
     1 
    2 3 
   4 5 6 
  7 8 9 10 
</pre>

</ul>

<p>
Ausgabe einer Pyramide mit inkrementeller Zahlenfolge auf dem Kopf:
</p>
<pre>
public void printNumberTrianlgeUpsideDown(int numberOfRows) {
    int numberToPrint = 0;
    for (int i = 0; i &lt;= numberOfRows; i++) {
        numberToPrint = numberToPrint + i;
    }
    for (int j = numberOfRows; j &gt; 0; j--) {
        for (int k = numberOfRows - j; k &gt; 0; k--) {
            System.out.print(" ");
        }
        for (int l = 0; l &lt;= j - 1; l++) {
            System.out.print(numberToPrint + " ");
            numberToPrint--;
        }
        System.out.println();
    }
}
</pre>
<ul>
<li>
Ergebnis:
<pre>
jshell&gt; printNumberTrianlgeUpsideDown(4)
10 9 8 7 
 6 5 4 
  3 2 
   1 
</pre>

</ul>
<div id="Print Diamond Shape"><h3 id="Print Diamond Shape" class="header"><a href="#Print Diamond Shape">Print Diamond Shape</a></h3></div>
<p>
Grundsätzlich muss man sich das als eine Matrix vorstellen, mit Zeilen und Spalten:
</p>
<pre>
der Underscore soll hier ein als Lehrzeichen gemeint sein.

|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|---+---+---+---+---+---+---+---+---+---|
| 0 | _ | _ | _ | _ | * |   |   |   |   |
|---+---+---+---+---+---+---+---+---+---|
| 1 | _ | _ | _ | * | _ | * |   |   |   |
|---+---+---+---+---+---+---+---+---+---|
| 2 | _ | _ | * | _ | _ | _ | * |   |   |
|---+---+---+---+---+---+---+---+---+---|
| 3 | _ | * | _ | _ | _ | _ | _ | * |   |
|---+---+---+---+---+---+---+---+---+---|
| 4 | * | _ | _ | _ | _ | _ | _ | _ | * |    &lt;--- bis hier läuft der obere teil der Pyramide
|---+---+---+---+---+---+---+---+---+---|
| 3 | _ | * | _ | _ | _ | _ | _ | * |   |    &lt;--- ab hier wird eine zweite Pyramide auf dem Kopf ausgegeben
|---+---+---+---+---+---+---+---+---+---|
| 2 | _ | _ | * | _ | _ | _ | * |   |   |
|---+---+---+---+---+---+---+---+---+---|
| 1 | _ | _ | _ | * | _ | * |   |   |   |
|---+---+---+---+---+---+---+---+---+---|
| 0 | _ | _ | _ | _ | * |   |   |   |   |
</pre>

<pre>
public void drawHollowDiamondShape(int maxWidth) {
    for (int i = 0; i &lt; maxWidth; i ++) {
        for (int j = 0; j &lt; maxWidth - i; j++) {
            System.out.print(" ");
        }
        for (int k = 0; k &lt; 2 * i + 1; k++) {
            if (k == 0 || k == 2 * i) {
                System.out.print("*");
            } else {
                System.out.print(" ");
            }
        }
        System.out.println();
    }
    for (int i = maxWidth - 2; i &gt;= 0; i--) {
        for (int j = 0; j &lt; maxWidth - i; j++) {
            System.out.print(" ");
        }
        for (int k = 0; k &lt; 2 * i + 1; k++) {
           if (k == 0 || k == 2 * i) {
                System.out.print("*");
            } else {
                System.out.print(" ");
            }
        }
        System.out.println();
    }
}
</pre>
<ul>
<li>
Wie schon bei dem Pyramiden mit Zahlen, müssen ersteinmal die Lehrzeiche in jeder Zeiel ausgegeben werden.

<li>
Der Check/Bedingung für einen Zeilendurchlauf mit Zeichen ist: <code>2 * i + 1</code>

<ul>
<li>
Das stellt sicher, dass immer eine ungerade Zahl als Check für die Schleife ist.

</ul>
<li>
Um den Diamanten leehr zu machen, ist dieser Guard: <code>(k == 0 || k == 2 * i)</code>

<ul>
<li>
Eine andere variante ist: <code>(k % 2 == 0)</code> - Dann wird nur jeder zweite Stern ausgegeben.

</ul>
<li>
Ergebnis:
<pre>
jshell&gt; drawHollowDiamondShape(5)
     *
    * *
   *   *
  *     *
 *       *
  *     *
   *   *
    * *
     *
</pre>

</ul>

<ul>
<li>
Refactoring:

<ul>
<li>
Der ganze Code-Block ist so etwas groß und widerholt sich an einigen Stellen.

<li>
Als erstes kann man eine Methode extrahieren, die die Lehrzeichen ausgibt:
<pre>
private void drawSpaces(int size, int currentRow) {
    int numberOfSpaces = size - currentRow;
    for (int column = 0; column &lt;= numberOfSpaces - 1; column++) {
        System.out.print(" ");
    }
}
</pre>

<li>
Als nächste kann die Mehtode extrachiert werden, um die Sterne auszugeben:
<pre>
private void drawStars(int currentRow) {
    int numberOfColumns = currentRow * 2 + 1;
    for (int column = 0; column &lt;= numberOfColumns - 1; column++) {
        if (column == 0 || column == 2 * currentRow) {
            System.out.print("*");
        } else {
            System.out.print(" ");
        }
    }
}
</pre>

<li>
Als nächstes kann der Diamand in zwei methoden aufgeteilt werden. Eine Methode für den oberen und unteren teil:
<pre>
private void drawUpperPart(int numberOfRows) {
    for (int currentRow = 0; currentRow &lt;= numberOfRows - 1; currentRow++) {
        drawSpaces(numberOfRows, currentRow);
        drawStars(currentRow);
        System.out.println();
    }
}
</pre>

<li>
und unterer Teil:
<pre>
private void drawLowerPart(int numberOfRows) {
    for (int currentRow = numberOfRows - 2; currentRow &gt;= 0; currentRow--) {
        drawSpaces(numberOfRows, currentRow);
        drawStars(currentRow);
        System.out.println();
    }
}
</pre>

<li>
zum Schluss beide methoden in einer aufrufen:
<pre>
jshell&gt; public void drawDiamond(int size) {
   ...&gt;     drawUpperPart(size);
   ...&gt;     drawLowerPart(size);
   ...&gt; }
|  created method drawDiamond(int)
jshell&gt; drawDiamond(5)
     *
    * *
   *   *
  *     *
 *       *
  *     *
   *   *
    * *
     *
</pre>

</ul>
</ul>

<ul>
<li>
Eine andere Möglichkeit ohne trennung in zwei Methoden ist diese hier:
<pre>
public void drawDiamondShapeV2(int size) {
    int maxRows = size * 2 - 2;
    for (int row = 0; row &lt;= maxRows; row++) {
        int width;
        int spaces;
        if (row &gt;= size) {
            width = (maxRows - row) * 2;
            spaces = size - (maxRows - row) - 1;
        } else {
            width = row * 2;
            spaces = size - row - 1;
        }
        for (int col = 0; col &lt; spaces; col++) {
            System.out.print(" ");
        }
        for (int col = 0; col &lt;= width; col++) {
            if (col == 0 || col == width) {
                System.out.print("*");
            } else {
                System.out.print(" ");
            }
        }
        System.out.println();
    }
}
</pre>

<ul>
<li>
Hier berechnen wir als erstes die maximale Länge der Zeilen mit dem übergeben Argumen <code>size * 2 - 2</code>.

<ul>
<li>
bei einem Beispiel wert von <code>5</code> verdoppel wir den wert auf <code>2</code> und subtrahieren <code>-2</code>.

<li>
Eine Zeile wird abgerechten weil die untere Pyramide eine Zeile weniger hat.

<li>
Die zweite Zeile muss nur dann abgezogen, wenn die Zeilen bei den Schleifen mit <code>0</code> inizialisiert werden.

</ul>
<li>
Für jede Zeile müssen zwei Variablen ermittelt werden.

<ol>
<li>
Der Abstand zum Zeilenanfang und dem ersten Charcter der Pyramide <code>int spaces</code>

<li>
Die Breite der Pyramide in der aktuellen Zeile <code>int width</code>

</ol>
<li>
Dabei muss aber unterschieden werden, ob wir uns aktuell im oberen oder unteren Teil der Pyramide befinden.

<ul>
<li>
Überprüfen, ob die aktuelle Zeiel größer oder gleich des übergenen Argumentes <code>size</code> ist: <code>row &gt;= size</code>

<li>
Im oberen teil findet diese Zuordnung statt:

<ul>
<li>
<code>width = row * 2</code>

<li>
<code>spaces = size - row - 1</code>

</ul>
<li>
Im unteren teil wiederum diese:

<ul>
<li>
<code>width = (maxRows - row) * 2</code>

<li>
<code>spaces = size - (maxRows - row) - 1</code>

</ul>
</ul>
<li>
Mit diesen Werten kann dann einfach für die aktuelle Zeile die Lehrzeichen und die Sterne ausgegeben werden.

</ul>
</ul>

</body>
</html>
